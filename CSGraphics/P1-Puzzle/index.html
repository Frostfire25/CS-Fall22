<html>
<head>
    <title>Three.js Framework Example</title>
</head>
<body>

<canvas id="myCanvas"></canvas>

<script type="module">

// Start of Javascript code

import * as THREE from "http://cs.merrimack.edu/~stuetzlec/three.js-master/build/three.module.js";
import { ConvexGeometry } from "http://cs.merrimack.edu/~stuetzlec/three.js-master/examples/jsm/geometries/ConvexGeometry.js";
import { DragControls } from 'http://cs.merrimack.edu/~stuetzlec/three.js-master/examples/jsm/controls/DragControls'

// Creating Scene and Camera
var scene = new THREE.Scene();

var camera = new THREE.PerspectiveCamera( 35, window.innerWidth / window.innerHeight, .1, 3000 );
camera.position.z = 3;  // Try moving this around!
camera.lookAt( new THREE.Vector3(0.0,0.0,0.0));
scene.add( camera );

// Renderer 

var renderer = new THREE.WebGLRenderer({canvas: myCanvas, antialias: true});
//renderer.setClearColor( 0xffffff, 1 );
renderer.setClearColor( new THREE.Color( 'aqua' ), 1 );
// If you want this to span the window, instead of using the myCanvas object, use the window object
renderer.setPixelRatio(window.devicePixelRatio * 1.01);
renderer.setSize(window.innerWidth, window.innerHeight);

// Objects & Functions
// Gets a random number
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random
function getRandomArbitrary(min, max) {
  return Math.random() * (max - min) + min;
}

// Gets a random integer
// https://stackoverflow.com/questions/1527803/generating-random-whole-numbers-in-javascript-in-a-specific-range
function getRandomArbitraryInt(min, max) {
    min = Math.ceil(min);
    max = Math.floor(max);
    return Math.floor(Math.random() * (max - min + 1)) + min;
}

// Represents a point in the puzzle box
class point2D {

    constructor(x, y) {
      this.x = x;
      this.y = y;
    }

    toString() {
        return `[${this.x} , ${this.y}]`;
    };

}

class puzzle_piece {

  constructor(points, color, mesh) {
    this.points = points;
    this.color = color;
    this.mesh = mesh;
    this.starting_X = mesh.position.x.valueOf();
    this.starting_Y = mesh.position.y.valueOf();
    // Attribute that determines if this puzzle piece is in place
    this.inPlace = false;
  }  

}

// Initilizing Objects

const PUZZLE_WIDTH = 1;
const PUZZLE_HEIGHT = 1;
const NUMBER_OF_PIECES = 9;
const X_LEVEL = 0;
const Y_LEVEL = 0;
// The bounds that a piece must be in to be recognized as set and to snap into place.
const SNAP_BOUNDS = 0.010;

// Creating black outline box for puzzle
const geometry = new THREE.BoxGeometry( PUZZLE_WIDTH + 0.025, PUZZLE_HEIGHT + 0.025, 0 );
const material = new THREE.MeshBasicMaterial( {color: new THREE.Color( 'black' )} );
const cube = new THREE.Mesh( geometry, material );
cube.position.setX(X_LEVEL);
cube.position.setY(Y_LEVEL);
scene.add( cube );

// Creating the inside box
const insideBox = new THREE.BoxGeometry( PUZZLE_WIDTH, PUZZLE_HEIGHT, 0 );
const insideBoxM = new THREE.MeshBasicMaterial( {color: new THREE.Color( 'white' )} );
const insidBoxCube = new THREE.Mesh( insideBox, insideBoxM );
insidBoxCube.position.setX(X_LEVEL);
insidBoxCube.position.setY(Y_LEVEL);
scene.add( insidBoxCube );

// Defining the center point of the puzzle
var x = getRandomArbitrary(-0.25 * PUZZLE_WIDTH, 0.25 * PUZZLE_WIDTH);
var y = getRandomArbitrary(-0.25 * PUZZLE_HEIGHT, 0.25 * PUZZLE_HEIGHT);
const center = new point2D(x, y);
console.log(`[${x} , ${y}]`);



var puzzle_pieces = [];

const W2 = PUZZLE_WIDTH/2;
const H2 = PUZZLE_HEIGHT/2;

var timesRan = 0;
var puzzle_piece_meshes = [];
// Draws a triangle based off of the points.
function drawTriangle(v, point, center) {
    var triG = new THREE.Geometry();
    triG.vertices.push(new THREE.Vector3(center.x, center.y, 0));
    triG.vertices.push(new THREE.Vector3(point.x, point.y, 0));
    triG.vertices.push(new THREE.Vector3(v.x, v.y, 0));
    triG.faces.push(new THREE.Face3(0, 1, 2, new THREE.Vector3(0, 0, 1)));

    var color = new THREE.Color();
    color.setHex(Math.random() * 0xffffff);

    var mat = new THREE.MeshBasicMaterial( {color: color, side: THREE.DoubleSide} );
    var mesh = new THREE.Mesh(triG, mat);
    scene.add(mesh);

    // Create piece object for storing data
    var piece = new puzzle_piece([v, point, center], color, mesh);
    puzzle_pieces.push(piece);
    puzzle_piece_meshes.push(mesh);

    timesRan ++;
    return piece;
}


// Top 
var num_top = getRandomArbitraryInt(2, Math.ceil((NUMBER_OF_PIECES / 3)));
console.log("Num top "+ num_top);
var vertexes_top = new Array(num_top);
// Add in all of the vertexs for top
for(var i = 0; i < num_top; i++) {
  vertexes_top[i] = new point2D(getRandomArbitrary(-W2, W2), H2);
}
// Sort the vertexes
vertexes_top = vertexes_top.sort(function(a, b) { return a.x - b.x; });
// Add in all of the top triangles
var prev_top = undefined;
for(var i = 0; i < num_top; i++) {
  var vertex = vertexes_top[i];
  // If this is the first run
  if(i == 0) { drawTriangle(center, vertex, new point2D(-W2, H2))} 
  // If this is the last run
  else if(i == (num_top - 1)) { drawTriangle(center, prev_top, new point2D(W2, H2));}
  // If this is a middle run
  else { drawTriangle(vertex, prev_top, center); }
  prev_top = vertex; 
}


// Right
var num_right = getRandomArbitraryInt(2, Math.ceil((NUMBER_OF_PIECES / 3)));
var vertexes_right = new Array(num_right);
for(var i = 0; i < num_right; i++) {
  vertexes_right[i] = new point2D(W2, getRandomArbitrary(-H2, H2));
}
// Sort the vertexes
vertexes_right.sort(function(a, b) { return a.y - b.y; });
// Add in all of the right triangles
var prev_right = undefined;
for(var i = 0; i < num_right; i++) {
  var vertex = vertexes_right[i];
  // If this is the first run
  if(i == 0) { drawTriangle(center, vertex, new point2D(W2, -H2));} 
  // If this is the last run
  else if(i == (num_right - 1)) { drawTriangle(center, prev_right, new point2D(W2, H2));}
  // If this is a middle run
  else { drawTriangle(center, vertex, prev_right); }
  prev_right = vertex; 
}


// Bottom
var num_bottom = getRandomArbitraryInt(2, Math.ceil((NUMBER_OF_PIECES / 3)));
console.log("Num bottom "+ num_bottom);
var vertexes_bottom = new Array(num_bottom);
// Add in all of the vertexs for bottom
for(var i = 0; i < num_bottom; i++) {
  vertexes_bottom[i] = new point2D(getRandomArbitrary(-W2, W2), -H2);
}
// Sort the vertexes
vertexes_bottom.sort(function(a, b) { return a.x - b.x; });
// Add in all of the bottom triangles
var prev_bottom = undefined;
for(var i = 0; i < num_bottom; i++) {
  var vertex = vertexes_bottom[i];
  // If this is the first run
  if(i == 0) { drawTriangle(new point2D(-W2, -H2), vertex, center);} 
  // If this is the last run
  else if(i == (num_bottom - 1)) { drawTriangle(new point2D(W2, -H2), prev_bottom, center);}
  // If this is a middle run
  else { drawTriangle(vertex, prev_bottom, center); }
  prev_bottom = vertex; 
}

// Left
var num_left = Math.max(2, NUMBER_OF_PIECES - (num_top + num_right + num_bottom));
console.log("Num left "+ num_left);
var vertexes_left = new Array(num_left);
// Add in all of the vertexs for left
for(var i = 0; i < num_left; i++) {
  vertexes_left[i] = new point2D(-W2, getRandomArbitrary(-H2, H2));
}
// Sort the vertexes
vertexes_left.sort(function(a, b) { return a.y - b.y; });
// Add in all of the left triangles
var prev_left = undefined;
for(var i = 0; i < num_left; i++) {
  var vertex = vertexes_left[i];
  // If this is the first run
  if(i == 0) { drawTriangle(new point2D(-W2, -H2), vertex, center);} 
  // If this is the last run
  else if(i == (num_left - 1)) { drawTriangle(new point2D(-W2, H2), prev_left, center);}
  // If this is a middle run
  else { drawTriangle(vertex, prev_left, center); }
  prev_left = vertex; 
}

// Make all pieces draggable
var controls = new DragControls( puzzle_piece_meshes, camera, renderer.domElement );
//controls.addEventListener( 'dragstart', dragStart );
//controls.addEventListener( 'dragend', dragEnd );
controls.addEventListener( 'drag', drag );

// In our drag function we want to determine if a person moved a piece into its correct position, if they did then we want to set its to locked.
function drag(event) {
  // Find the puzzle piece we are on.
  //console.log(puzzle_pieces.find(piece => piece.mesh.id == event.object.id));
  console.log(isWithinPoints(puzzle_pieces.find(piece => piece.mesh.id == event.object.id), event.object));
}

// Determines if a puzzle piece is within the points that it needs to be
function isWithinPoints(puzzle_piece, object) {

  console.log("x: " + Math.abs(puzzle_piece.starting_X - object.position.x));
  console.log("y: " + Math.abs(puzzle_piece.starting_Y - object.position.y));

  if(Math.abs(puzzle_piece.starting_X - object.position.x) > SNAP_BOUNDS ||
      Math.abs(puzzle_piece.starting_Y - object.position.y) > SNAP_BOUNDS)
        return false;
  
  return true;
}




// Initiates graphical loops
animate();

function animate() {
   requestAnimationFrame(animate);
   render();
}

function render() {
  renderer.render( scene, camera );
}

</script>

</body>
</html>