<html>
<head>
    <title>Three.js Framework Example</title>
</head>
<body>

<canvas id="myCanvas"></canvas>

<script type="module">

// Start of Javascript code

import * as THREE from "http://cs.merrimack.edu/~stuetzlec/three.js-master/build/three.module.js";
import { ConvexGeometry } from "http://cs.merrimack.edu/~stuetzlec/three.js-master/examples/jsm/geometries/ConvexGeometry.js";

// Creating Scene and Camera
var scene = new THREE.Scene();

var camera = new THREE.PerspectiveCamera( 35, window.innerWidth / window.innerHeight, .1, 3000 );
camera.position.z = 3;  // Try moving this around!
camera.lookAt( new THREE.Vector3(0.0,0.0,0.0));
scene.add( camera );

// Renderer 

var renderer = new THREE.WebGLRenderer({canvas: myCanvas, antialias: true});
//renderer.setClearColor( 0xffffff, 1 );
renderer.setClearColor( new THREE.Color( 'aqua' ), 1 );
// If you want this to span the window, instead of using the myCanvas object, use the window object
renderer.setPixelRatio(window.devicePixelRatio * 1.01);
renderer.setSize(window.innerWidth, window.innerHeight);

// Objects & Functions

// Create the object to represent a triangle
function Triangle (a, b, c, color) {

this.vertices = [
  a[0], a[1], a[2],
  b[0], b[1], b[2],
  c[0], c[1], c[2]
];

this.color = color;

// The function that actually adds the triangle geometry to the scene
this.render = function() {
  // Create and assign the geometry
  this.geom = new THREE.BufferGeometry();  
  
  // Assign attributes to geometry
  this.geom.setAttribute( 'position', new THREE.BufferAttribute( new Float32Array(this.vertices), 3));
  this.geom.setAttribute( 'color' , this.color);

  this.material = new THREE.MeshBasicMaterial({ vertexColors: THREE.VertexColors });
  this.mesh = new THREE.Mesh( this.geom, this.material );

  scene.add(this.mesh);
 }	
}

function Square(a, b, c, d, color) {

this.vertices = [
  a[0], a[1], a[2],
  b[0], b[1], b[2],
  c[0], c[1], c[2],
  d[0], d[1], d[2]
];

this.color = color;

 // The function that actually adds the triangle geometry to the scene
 this.render = function() {
    this.lowerTri = new Triangle(a, b, c, this.color);
    this.upperTri = new Triangle(a, c, d, this.color);

    this.lowerTri.render();
    this.upperTri.render();
}	

}



// Gets a random number
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random
function getRandomArbitrary(min, max) {
  return Math.random() * (max - min) + min;
}

// Gets a random integer
// https://stackoverflow.com/questions/1527803/generating-random-whole-numbers-in-javascript-in-a-specific-range
function getRandomArbitraryInt(min, max) {
    min = Math.ceil(min);
    max = Math.floor(max);
    return Math.floor(Math.random() * (max - min + 1)) + min;
}

// Represents a point in the puzzle box
class point2D {

    constructor(x, y) {
      this.x = x;
      this.y = y;
    }

    toString() {
        return `[${this.x} , ${this.y}]`;
    };

}

class Piece {

  constructor(points, color) {
    this.points = points;
    this.color = color;
  }  

}

// Initilizing Objects

const PUZZLE_WIDTH = 1;
const PUZZLE_HEIGHT = 1;
const NUMBER_OF_PIECES = 6;
const X_LEVEL = 0;
const Y_LEVEL = 0;

// Creating black outline box for puzzle
const geometry = new THREE.BoxGeometry( PUZZLE_WIDTH + 0.025, PUZZLE_HEIGHT + 0.025, 0 );
const material = new THREE.MeshBasicMaterial( {color: new THREE.Color( 'black' )} );
const cube = new THREE.Mesh( geometry, material );
cube.position.setX(X_LEVEL);
cube.position.setY(Y_LEVEL);
scene.add( cube );

// Creating the inside box
const insideBox = new THREE.BoxGeometry( PUZZLE_WIDTH, PUZZLE_HEIGHT, 0 );
const insideBoxM = new THREE.MeshBasicMaterial( {color: new THREE.Color( 'white' )} );
const insidBoxCube = new THREE.Mesh( insideBox, insideBoxM );
insidBoxCube.position.setX(X_LEVEL);
insidBoxCube.position.setY(Y_LEVEL);
scene.add( insidBoxCube );

// Draw # of Pieces (NUMBER_OF_PIECES)

var prior_point = null;
for(var i = 0; i < NUMBER_OF_PIECES + 1; i++) {
   
    
    // Get random values for this point.
    var x = getRandomArbitrary(0, PUZZLE_WIDTH);
    var y = getRandomArbitrary(0, PUZZLE_HEIGHT);

    // Creates a random point
    var point = new point2D(x, y);      

    // Draw Shape
    if(prior_point != null) {
      
      // Creates a random color
      var color = new THREE.Color();
      color.setHex(Math.random() * 0xffffff);
      


    } 

    prior_point = point;
    

}

// Defining the center point of the puzzle
var x = getRandomArbitrary(-0.25 * PUZZLE_WIDTH, 0.25 * PUZZLE_WIDTH);
var y = getRandomArbitrary(-0.25 * PUZZLE_HEIGHT, 0.25 * PUZZLE_HEIGHT);
const center = new point2D(x, y);
console.log(`[${x} , ${y}]`);

const b1G = new THREE.BoxGeometry( 0.01, 0.01, 0 );
const b1M = new THREE.MeshBasicMaterial( {color: new THREE.Color( 'orange' )} );
const b1 = new THREE.Mesh( b1G, b1M );
b1.position.setX(x);
b1.position.setY(y);
b1.position.setZ(insidBoxCube.position.z + .01);
scene.add( b1 );


const b3G = new THREE.BoxGeometry( 0.01, 0.01, 0 );
const b3M = new THREE.MeshBasicMaterial( {color: new THREE.Color( 'red' )} );
const b3 = new THREE.Mesh( b3G, b3M );
b3.position.setX(0);
b3.position.setY(0);
b3.position.setZ(insidBoxCube.position.z + .01);
scene.add( b3 );

const b2G = new THREE.BoxGeometry( 0.1, 0.1, 0 );
const b2M = new THREE.MeshBasicMaterial( {color: new THREE.Color( 'red' )} );
const b2 = new THREE.Mesh( b2G, b2M );
b2.position.setX(0.5);
b2.position.setY(0.5);
b2.position.setZ(insidBoxCube.position.z + .01);
scene.add( b2 );


console.log( insidBoxCube );






var vertexs_drawn = 0;
var vertexs = new Array(NUMBER_OF_PIECES);
var pos = 0;

const W2 = PUZZLE_WIDTH/2;
const H2 = PUZZLE_HEIGHT/2;

// Top 
var num_top = getRandomArbitraryInt(1, Math.ceil((NUMBER_OF_PIECES / 3)));
// Add in all of the vertexs for top
for(var i = 0; i < num_top; i++) {
  vertexs[pos++] = new point2D(getRandomArbitrary(-W2, W2), H2);
}

// Right
var num_right = getRandomArbitraryInt(1, Math.ceil((NUMBER_OF_PIECES / 3)));
// Add in all of the vertexs for right
for(var i = 0; i < num_right; i++) {
  vertexs[pos++] = new point2D(W2, getRandomArbitrary(-H2, H2));
}

// Bottom
var num_bottom = getRandomArbitraryInt(1, Math.ceil((NUMBER_OF_PIECES / 3)));
// Add in all of the vertexs for bottom
for(var i = 0; i < num_bottom; i++) {
  vertexs[pos++] = new point2D(getRandomArbitrary(-W2, W2), -H2);
}

// Left
var num_left = NUMBER_OF_PIECES - (num_top + num_right + num_bottom);
// Add in all of the vertexs for left
for(var i = 0; i < num_left; i++) {
  vertexs[pos++] = new point2D(-W2, getRandomArbitrary(-H2, H2));
}

console.log(`${num_top}  ${num_right}  ${num_bottom}  ${num_left}`);
console.log(vertexs);

// Draw out all of the triangles based on the vertexes
var v = vertexs[0];
for(var i = 1; i < vertexs.length; i++) {
    var point = vertexs[i];
    var triangleG = new THREE.Triangle(
      new THREE.Vector3(center.x, center.y, 0), 
      new THREE.Vector3(v.x, v.y, 0), 
      new THREE.Vector3(point.x, point.y, 0));
    var normal = triangleG.getNormal();

    var triG = new THREE.Geometry();
    triG.vertices.push(triangleG.a);
    triG.vertices.push(triangleG.b);
    triG.vertices.push(triangleG.c);
    triG.faces.push(new THREE.Face3(0, 1, 2, normal));

    var color = new THREE.Color();
    color.setHex(Math.random() * 0xffffff);

    var mat = new THREE.MeshBasicMaterial( {color: color} );
    var mesh = new THREE.Mesh(triG, mat);
    scene.add(mesh);   

    // Assign the last vertex to this point.
    v = point;

}

// Initiates graphical loops
animate();

function animate() {
   requestAnimationFrame(animate);
   render();
}

function render() {
  renderer.render( scene, camera );
}

</script>

</body>
</html>